{"ast":null,"code":"import _get from \"@babel/runtime/helpers/get\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _extends from \"@babel/runtime/helpers/extends\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport prefetchHelper from \"./prefetch\";\nimport emitter from \"./emitter\";\nimport { setMatchPaths, findPath, findMatchPath as _findMatchPath } from \"./find-path\";\nexport var PageResourceStatus = {\n  Error: \"error\",\n  Success: \"success\"\n};\n\nvar preferDefault = function preferDefault(m) {\n  return m && m.default || m;\n};\n\nvar stripSurroundingSlashes = function stripSurroundingSlashes(s) {\n  s = s[0] === \"/\" ? s.slice(1) : s;\n  s = s.endsWith(\"/\") ? s.slice(0, -1) : s;\n  return s;\n};\n\nvar createPageDataUrl = function createPageDataUrl(path) {\n  var fixedPath = path === \"/\" ? \"index\" : stripSurroundingSlashes(path);\n  return __PATH_PREFIX__ + \"/page-data/\" + fixedPath + \"/page-data.json\";\n};\n\nfunction doFetch(url) {\n  var method = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"GET\";\n  return new Promise(function (resolve, reject) {\n    var req = new XMLHttpRequest();\n    req.open(method, url, true);\n\n    req.onreadystatechange = function () {\n      if (req.readyState == 4) {\n        resolve(req);\n      }\n    };\n\n    req.send(null);\n  });\n}\n\nvar doesConnectionSupportPrefetch = function doesConnectionSupportPrefetch() {\n  if (\"connection\" in navigator && typeof navigator.connection !== \"undefined\") {\n    if ((navigator.connection.effectiveType || \"\").includes(\"2g\")) {\n      return false;\n    }\n\n    if (navigator.connection.saveData) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nvar toPageResources = function toPageResources(pageData) {\n  var component = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var page = {\n    componentChunkName: pageData.componentChunkName,\n    path: pageData.path,\n    webpackCompilationHash: pageData.webpackCompilationHash,\n    matchPath: pageData.matchPath,\n    staticQueryHashes: pageData.staticQueryHashes\n  };\n  return {\n    component: component,\n    json: pageData.result,\n    page: page\n  };\n};\n\nexport var BaseLoader = function () {\n  function BaseLoader(loadComponent, matchPaths) {\n    _classCallCheck(this, BaseLoader);\n\n    this.inFlightNetworkRequests = new Map();\n    this.pageDb = new Map();\n    this.inFlightDb = new Map();\n    this.staticQueryDb = new Map();\n    this.pageDataDb = new Map();\n    this.prefetchTriggered = new Set();\n    this.prefetchCompleted = new Set();\n    this.loadComponent = loadComponent;\n    setMatchPaths(matchPaths);\n  }\n\n  _createClass(BaseLoader, [{\n    key: \"memoizedGet\",\n    value: function memoizedGet(url) {\n      var _this = this;\n\n      var inFlightPromise = this.inFlightNetworkRequests.get(url);\n\n      if (!inFlightPromise) {\n        inFlightPromise = doFetch(url, \"GET\");\n        this.inFlightNetworkRequests.set(url, inFlightPromise);\n      }\n\n      return inFlightPromise.then(function (response) {\n        _this.inFlightNetworkRequests.delete(url);\n\n        return response;\n      }).catch(function (err) {\n        _this.inFlightNetworkRequests.delete(url);\n\n        throw err;\n      });\n    }\n  }, {\n    key: \"setApiRunner\",\n    value: function setApiRunner(apiRunner) {\n      this.apiRunner = apiRunner;\n      this.prefetchDisabled = apiRunner(\"disableCorePrefetching\").some(function (a) {\n        return a;\n      });\n    }\n  }, {\n    key: \"fetchPageDataJson\",\n    value: function fetchPageDataJson(loadObj) {\n      var _this2 = this;\n\n      var pagePath = loadObj.pagePath,\n          _loadObj$retries = loadObj.retries,\n          retries = _loadObj$retries === void 0 ? 0 : _loadObj$retries;\n      var url = createPageDataUrl(pagePath);\n      return this.memoizedGet(url).then(function (req) {\n        var status = req.status,\n            responseText = req.responseText;\n\n        if (status === 200) {\n          try {\n            var jsonPayload = JSON.parse(responseText);\n\n            if (jsonPayload.path === undefined) {\n              throw new Error(\"not a valid pageData response\");\n            }\n\n            return _extends(loadObj, {\n              status: PageResourceStatus.Success,\n              payload: jsonPayload\n            });\n          } catch (err) {}\n        }\n\n        if (status === 404 || status === 200) {\n          if (pagePath === \"/404.html\") {\n            return _extends(loadObj, {\n              status: PageResourceStatus.Error\n            });\n          }\n\n          return _this2.fetchPageDataJson(_extends(loadObj, {\n            pagePath: \"/404.html\",\n            notFound: true\n          }));\n        }\n\n        if (status === 500) {\n          return _extends(loadObj, {\n            status: PageResourceStatus.Error\n          });\n        }\n\n        if (retries < 3) {\n          return _this2.fetchPageDataJson(_extends(loadObj, {\n            retries: retries + 1\n          }));\n        }\n\n        return _extends(loadObj, {\n          status: PageResourceStatus.Error\n        });\n      });\n    }\n  }, {\n    key: \"loadPageDataJson\",\n    value: function loadPageDataJson(rawPath) {\n      var _this3 = this;\n\n      var pagePath = findPath(rawPath);\n\n      if (this.pageDataDb.has(pagePath)) {\n        return Promise.resolve(this.pageDataDb.get(pagePath));\n      }\n\n      return this.fetchPageDataJson({\n        pagePath: pagePath\n      }).then(function (pageData) {\n        _this3.pageDataDb.set(pagePath, pageData);\n\n        return pageData;\n      });\n    }\n  }, {\n    key: \"findMatchPath\",\n    value: function findMatchPath(rawPath) {\n      return _findMatchPath(rawPath);\n    }\n  }, {\n    key: \"loadPage\",\n    value: function loadPage(rawPath) {\n      var _this4 = this;\n\n      var pagePath = findPath(rawPath);\n\n      if (this.pageDb.has(pagePath)) {\n        var page = this.pageDb.get(pagePath);\n        return Promise.resolve(page.payload);\n      }\n\n      if (this.inFlightDb.has(pagePath)) {\n        return this.inFlightDb.get(pagePath);\n      }\n\n      var inFlightPromise = Promise.all([this.loadAppData(), this.loadPageDataJson(pagePath)]).then(function (allData) {\n        var result = allData[1];\n\n        if (result.status === PageResourceStatus.Error) {\n          return {\n            status: PageResourceStatus.Error\n          };\n        }\n\n        var pageData = result.payload;\n        var _pageData = pageData,\n            componentChunkName = _pageData.componentChunkName,\n            _pageData$staticQuery = _pageData.staticQueryHashes,\n            staticQueryHashes = _pageData$staticQuery === void 0 ? [] : _pageData$staticQuery;\n        var finalResult = {};\n\n        var componentChunkPromise = _this4.loadComponent(componentChunkName).then(function (component) {\n          finalResult.createdAt = new Date();\n          var pageResources;\n\n          if (!component) {\n            finalResult.status = PageResourceStatus.Error;\n          } else {\n            finalResult.status = PageResourceStatus.Success;\n\n            if (result.notFound === true) {\n              finalResult.notFound = true;\n            }\n\n            pageData = _extends(pageData, {\n              webpackCompilationHash: allData[0] ? allData[0].webpackCompilationHash : \"\"\n            });\n            pageResources = toPageResources(pageData, component);\n          }\n\n          return pageResources;\n        });\n\n        var staticQueryBatchPromise = Promise.all(staticQueryHashes.map(function (staticQueryHash) {\n          if (_this4.staticQueryDb.has(staticQueryHash)) {\n            var jsonPayload = _this4.staticQueryDb.get(staticQueryHash);\n\n            return {\n              staticQueryHash: staticQueryHash,\n              jsonPayload: jsonPayload\n            };\n          }\n\n          return _this4.memoizedGet(__PATH_PREFIX__ + \"/static/d/\" + staticQueryHash + \".json\").then(function (req) {\n            var jsonPayload = JSON.parse(req.responseText);\n            return {\n              staticQueryHash: staticQueryHash,\n              jsonPayload: jsonPayload\n            };\n          });\n        })).then(function (staticQueryResults) {\n          var staticQueryResultsMap = {};\n          staticQueryResults.forEach(function (_ref) {\n            var staticQueryHash = _ref.staticQueryHash,\n                jsonPayload = _ref.jsonPayload;\n            staticQueryResultsMap[staticQueryHash] = jsonPayload;\n\n            _this4.staticQueryDb.set(staticQueryHash, jsonPayload);\n          });\n          return staticQueryResultsMap;\n        });\n        return Promise.all([componentChunkPromise, staticQueryBatchPromise]).then(function (_ref2) {\n          var _ref3 = _slicedToArray(_ref2, 2),\n              pageResources = _ref3[0],\n              staticQueryResults = _ref3[1];\n\n          var payload;\n\n          if (pageResources) {\n            payload = _objectSpread(_objectSpread({}, pageResources), {}, {\n              staticQueryResults: staticQueryResults\n            });\n            finalResult.payload = payload;\n            emitter.emit(\"onPostLoadPageResources\", {\n              page: payload,\n              pageResources: payload\n            });\n          }\n\n          _this4.pageDb.set(pagePath, finalResult);\n\n          return payload;\n        });\n      });\n      inFlightPromise.then(function (response) {\n        _this4.inFlightDb.delete(pagePath);\n      }).catch(function (error) {\n        _this4.inFlightDb.delete(pagePath);\n\n        throw error;\n      });\n      this.inFlightDb.set(pagePath, inFlightPromise);\n      return inFlightPromise;\n    }\n  }, {\n    key: \"loadPageSync\",\n    value: function loadPageSync(rawPath) {\n      var pagePath = findPath(rawPath);\n\n      if (this.pageDb.has(pagePath)) {\n        var pageData = this.pageDb.get(pagePath).payload;\n        return pageData;\n      }\n\n      return undefined;\n    }\n  }, {\n    key: \"shouldPrefetch\",\n    value: function shouldPrefetch(pagePath) {\n      if (!doesConnectionSupportPrefetch()) {\n        return false;\n      }\n\n      if (this.pageDb.has(pagePath)) {\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"prefetch\",\n    value: function prefetch(pagePath) {\n      var _this5 = this;\n\n      if (!this.shouldPrefetch(pagePath)) {\n        return false;\n      }\n\n      if (!this.prefetchTriggered.has(pagePath)) {\n        this.apiRunner(\"onPrefetchPathname\", {\n          pathname: pagePath\n        });\n        this.prefetchTriggered.add(pagePath);\n      }\n\n      if (this.prefetchDisabled) {\n        return false;\n      }\n\n      var realPath = findPath(pagePath);\n      this.doPrefetch(realPath).then(function () {\n        if (!_this5.prefetchCompleted.has(pagePath)) {\n          _this5.apiRunner(\"onPostPrefetchPathname\", {\n            pathname: pagePath\n          });\n\n          _this5.prefetchCompleted.add(pagePath);\n        }\n      });\n      return true;\n    }\n  }, {\n    key: \"doPrefetch\",\n    value: function doPrefetch(pagePath) {\n      throw new Error(\"doPrefetch not implemented\");\n    }\n  }, {\n    key: \"hovering\",\n    value: function hovering(rawPath) {\n      this.loadPage(rawPath);\n    }\n  }, {\n    key: \"getResourceURLsForPathname\",\n    value: function getResourceURLsForPathname(rawPath) {\n      var pagePath = findPath(rawPath);\n      var page = this.pageDataDb.get(pagePath);\n\n      if (page) {\n        var pageResources = toPageResources(page.payload);\n        return [].concat(_toConsumableArray(createComponentUrls(pageResources.page.componentChunkName)), [createPageDataUrl(pagePath)]);\n      } else {\n        return null;\n      }\n    }\n  }, {\n    key: \"isPageNotFound\",\n    value: function isPageNotFound(rawPath) {\n      var pagePath = findPath(rawPath);\n      var page = this.pageDb.get(pagePath);\n      return page && page.notFound === true;\n    }\n  }, {\n    key: \"loadAppData\",\n    value: function loadAppData() {\n      var _this6 = this;\n\n      var retries = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      return this.memoizedGet(__PATH_PREFIX__ + \"/page-data/app-data.json\").then(function (req) {\n        var status = req.status,\n            responseText = req.responseText;\n        var appData;\n\n        if (status !== 200 && retries < 3) {\n          return _this6.loadAppData(retries + 1);\n        }\n\n        if (status === 200) {\n          try {\n            var jsonPayload = JSON.parse(responseText);\n\n            if (jsonPayload.webpackCompilationHash === undefined) {\n              throw new Error(\"not a valid app-data response\");\n            }\n\n            appData = jsonPayload;\n          } catch (err) {}\n        }\n\n        return appData;\n      });\n    }\n  }]);\n\n  return BaseLoader;\n}();\n\nvar createComponentUrls = function createComponentUrls(componentChunkName) {\n  return (window.___chunkMapping[componentChunkName] || []).map(function (chunk) {\n    return __PATH_PREFIX__ + chunk;\n  });\n};\n\nexport var ProdLoader = function (_BaseLoader) {\n  _inherits(ProdLoader, _BaseLoader);\n\n  var _super = _createSuper(ProdLoader);\n\n  function ProdLoader(asyncRequires, matchPaths) {\n    _classCallCheck(this, ProdLoader);\n\n    var loadComponent = function loadComponent(chunkName) {\n      return asyncRequires.components[chunkName] ? asyncRequires.components[chunkName]().then(preferDefault).catch(function () {\n        return null;\n      }) : Promise.resolve();\n    };\n\n    return _super.call(this, loadComponent, matchPaths);\n  }\n\n  _createClass(ProdLoader, [{\n    key: \"doPrefetch\",\n    value: function doPrefetch(pagePath) {\n      var _this7 = this;\n\n      var pageDataUrl = createPageDataUrl(pagePath);\n      return prefetchHelper(pageDataUrl, {\n        crossOrigin: \"anonymous\",\n        as: \"fetch\"\n      }).then(function () {\n        return _this7.loadPageDataJson(pagePath);\n      }).then(function (result) {\n        if (result.status !== PageResourceStatus.Success) {\n          return Promise.resolve();\n        }\n\n        var pageData = result.payload;\n        var chunkName = pageData.componentChunkName;\n        var componentUrls = createComponentUrls(chunkName);\n        return Promise.all(componentUrls.map(prefetchHelper)).then(function () {\n          return pageData;\n        });\n      });\n    }\n  }, {\n    key: \"loadPageDataJson\",\n    value: function loadPageDataJson(rawPath) {\n      return _get(_getPrototypeOf(ProdLoader.prototype), \"loadPageDataJson\", this).call(this, rawPath).then(function (data) {\n        if (data.notFound) {\n          return doFetch(rawPath, \"HEAD\").then(function (req) {\n            if (req.status === 200) {\n              return {\n                status: PageResourceStatus.Error\n              };\n            }\n\n            return data;\n          });\n        }\n\n        return data;\n      });\n    }\n  }]);\n\n  return ProdLoader;\n}(BaseLoader);\nvar instance;\nexport var setLoader = function setLoader(_loader) {\n  instance = _loader;\n};\nexport var publicLoader = {\n  getResourcesForPathname: function getResourcesForPathname(rawPath) {\n    console.warn(\"Warning: getResourcesForPathname is deprecated. Use loadPage instead\");\n    return instance.i.loadPage(rawPath);\n  },\n  getResourcesForPathnameSync: function getResourcesForPathnameSync(rawPath) {\n    console.warn(\"Warning: getResourcesForPathnameSync is deprecated. Use loadPageSync instead\");\n    return instance.i.loadPageSync(rawPath);\n  },\n  enqueue: function enqueue(rawPath) {\n    return instance.prefetch(rawPath);\n  },\n  getResourceURLsForPathname: function getResourceURLsForPathname(rawPath) {\n    return instance.getResourceURLsForPathname(rawPath);\n  },\n  loadPage: function loadPage(rawPath) {\n    return instance.loadPage(rawPath);\n  },\n  loadPageSync: function loadPageSync(rawPath) {\n    return instance.loadPageSync(rawPath);\n  },\n  prefetch: function prefetch(rawPath) {\n    return instance.prefetch(rawPath);\n  },\n  isPageNotFound: function isPageNotFound(rawPath) {\n    return instance.isPageNotFound(rawPath);\n  },\n  hovering: function hovering(rawPath) {\n    return instance.hovering(rawPath);\n  },\n  loadAppData: function loadAppData() {\n    return instance.loadAppData();\n  }\n};\nexport default publicLoader;","map":{"version":3,"sources":["D:/MatchSite/.cache/loader.js"],"names":["prefetchHelper","emitter","setMatchPaths","findPath","findMatchPath","PageResourceStatus","Error","Success","preferDefault","m","default","stripSurroundingSlashes","s","slice","endsWith","createPageDataUrl","path","fixedPath","__PATH_PREFIX__","doFetch","url","method","Promise","resolve","reject","req","XMLHttpRequest","open","onreadystatechange","readyState","send","doesConnectionSupportPrefetch","navigator","connection","effectiveType","includes","saveData","toPageResources","pageData","component","page","componentChunkName","webpackCompilationHash","matchPath","staticQueryHashes","json","result","BaseLoader","loadComponent","matchPaths","inFlightNetworkRequests","Map","pageDb","inFlightDb","staticQueryDb","pageDataDb","prefetchTriggered","Set","prefetchCompleted","inFlightPromise","get","set","then","response","delete","catch","err","apiRunner","prefetchDisabled","some","a","loadObj","pagePath","retries","memoizedGet","status","responseText","jsonPayload","JSON","parse","undefined","payload","fetchPageDataJson","notFound","rawPath","has","all","loadAppData","loadPageDataJson","allData","finalResult","componentChunkPromise","createdAt","Date","pageResources","staticQueryBatchPromise","map","staticQueryHash","staticQueryResults","staticQueryResultsMap","forEach","emit","error","shouldPrefetch","pathname","add","realPath","doPrefetch","loadPage","createComponentUrls","appData","window","___chunkMapping","chunk","ProdLoader","asyncRequires","chunkName","components","pageDataUrl","crossOrigin","as","componentUrls","data","instance","setLoader","_loader","publicLoader","getResourcesForPathname","console","warn","i","getResourcesForPathnameSync","loadPageSync","enqueue","prefetch","getResourceURLsForPathname","isPageNotFound","hovering"],"mappings":"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","sourcesContent":["import prefetchHelper from \"./prefetch\"\nimport emitter from \"./emitter\"\nimport { setMatchPaths, findPath, findMatchPath } from \"./find-path\"\n\n/**\n * Available resource loading statuses\n */\nexport const PageResourceStatus = {\n  /**\n   * At least one of critical resources failed to load\n   */\n  Error: `error`,\n  /**\n   * Resources loaded successfully\n   */\n  Success: `success`,\n}\n\nconst preferDefault = m => (m && m.default) || m\n\nconst stripSurroundingSlashes = s => {\n  s = s[0] === `/` ? s.slice(1) : s\n  s = s.endsWith(`/`) ? s.slice(0, -1) : s\n  return s\n}\n\nconst createPageDataUrl = path => {\n  const fixedPath = path === `/` ? `index` : stripSurroundingSlashes(path)\n  return `${__PATH_PREFIX__}/page-data/${fixedPath}/page-data.json`\n}\n\nfunction doFetch(url, method = `GET`) {\n  return new Promise((resolve, reject) => {\n    const req = new XMLHttpRequest()\n    req.open(method, url, true)\n    req.onreadystatechange = () => {\n      if (req.readyState == 4) {\n        resolve(req)\n      }\n    }\n    req.send(null)\n  })\n}\n\nconst doesConnectionSupportPrefetch = () => {\n  if (\n    `connection` in navigator &&\n    typeof navigator.connection !== `undefined`\n  ) {\n    if ((navigator.connection.effectiveType || ``).includes(`2g`)) {\n      return false\n    }\n    if (navigator.connection.saveData) {\n      return false\n    }\n  }\n  return true\n}\n\nconst toPageResources = (pageData, component = null) => {\n  const page = {\n    componentChunkName: pageData.componentChunkName,\n    path: pageData.path,\n    webpackCompilationHash: pageData.webpackCompilationHash,\n    matchPath: pageData.matchPath,\n    staticQueryHashes: pageData.staticQueryHashes,\n  }\n\n  return {\n    component,\n    json: pageData.result,\n    page,\n  }\n}\n\nexport class BaseLoader {\n  constructor(loadComponent, matchPaths) {\n    // Map of pagePath -> Page. Where Page is an object with: {\n    //   status: PageResourceStatus.Success || PageResourceStatus.Error,\n    //   payload: PageResources, // undefined if PageResourceStatus.Error\n    // }\n    // PageResources is {\n    //   component,\n    //   json: pageData.result,\n    //   page: {\n    //     componentChunkName,\n    //     path,\n    //     webpackCompilationHash,\n    //     staticQueryHashes\n    //   },\n    //   staticQueryResults\n    // }\n    this.pageDb = new Map()\n    this.inFlightDb = new Map()\n    this.staticQueryDb = new Map()\n    this.pageDataDb = new Map()\n    this.prefetchTriggered = new Set()\n    this.prefetchCompleted = new Set()\n    this.loadComponent = loadComponent\n    setMatchPaths(matchPaths)\n  }\n\n  inFlightNetworkRequests = new Map()\n\n  memoizedGet(url) {\n    let inFlightPromise = this.inFlightNetworkRequests.get(url)\n\n    if (!inFlightPromise) {\n      inFlightPromise = doFetch(url, `GET`)\n      this.inFlightNetworkRequests.set(url, inFlightPromise)\n    }\n\n    // Prefer duplication with then + catch over .finally to prevent problems in ie11 + firefox\n    return inFlightPromise\n      .then(response => {\n        this.inFlightNetworkRequests.delete(url)\n        return response\n      })\n      .catch(err => {\n        this.inFlightNetworkRequests.delete(url)\n        throw err\n      })\n  }\n\n  setApiRunner(apiRunner) {\n    this.apiRunner = apiRunner\n    this.prefetchDisabled = apiRunner(`disableCorePrefetching`).some(a => a)\n  }\n\n  fetchPageDataJson(loadObj) {\n    const { pagePath, retries = 0 } = loadObj\n    const url = createPageDataUrl(pagePath)\n    return this.memoizedGet(url).then(req => {\n      const { status, responseText } = req\n\n      // Handle 200\n      if (status === 200) {\n        try {\n          const jsonPayload = JSON.parse(responseText)\n          if (jsonPayload.path === undefined) {\n            throw new Error(`not a valid pageData response`)\n          }\n\n          return Object.assign(loadObj, {\n            status: PageResourceStatus.Success,\n            payload: jsonPayload,\n          })\n        } catch (err) {\n          // continue regardless of error\n        }\n      }\n\n      // Handle 404\n      if (status === 404 || status === 200) {\n        // If the request was for a 404 page and it doesn't exist, we're done\n        if (pagePath === `/404.html`) {\n          return Object.assign(loadObj, {\n            status: PageResourceStatus.Error,\n          })\n        }\n\n        // Need some code here to cache the 404 request. In case\n        // multiple loadPageDataJsons result in 404s\n        return this.fetchPageDataJson(\n          Object.assign(loadObj, { pagePath: `/404.html`, notFound: true })\n        )\n      }\n\n      // handle 500 response (Unrecoverable)\n      if (status === 500) {\n        return Object.assign(loadObj, {\n          status: PageResourceStatus.Error,\n        })\n      }\n\n      // Handle everything else, including status === 0, and 503s. Should retry\n      if (retries < 3) {\n        return this.fetchPageDataJson(\n          Object.assign(loadObj, { retries: retries + 1 })\n        )\n      }\n\n      // Retried 3 times already, result is an error.\n      return Object.assign(loadObj, {\n        status: PageResourceStatus.Error,\n      })\n    })\n  }\n\n  loadPageDataJson(rawPath) {\n    const pagePath = findPath(rawPath)\n    if (this.pageDataDb.has(pagePath)) {\n      return Promise.resolve(this.pageDataDb.get(pagePath))\n    }\n\n    return this.fetchPageDataJson({ pagePath }).then(pageData => {\n      this.pageDataDb.set(pagePath, pageData)\n\n      return pageData\n    })\n  }\n\n  findMatchPath(rawPath) {\n    return findMatchPath(rawPath)\n  }\n\n  // TODO check all uses of this and whether they use undefined for page resources not exist\n  loadPage(rawPath) {\n    const pagePath = findPath(rawPath)\n    if (this.pageDb.has(pagePath)) {\n      const page = this.pageDb.get(pagePath)\n      return Promise.resolve(page.payload)\n    }\n\n    if (this.inFlightDb.has(pagePath)) {\n      return this.inFlightDb.get(pagePath)\n    }\n\n    const inFlightPromise = Promise.all([\n      this.loadAppData(),\n      this.loadPageDataJson(pagePath),\n    ]).then(allData => {\n      const result = allData[1]\n      if (result.status === PageResourceStatus.Error) {\n        return {\n          status: PageResourceStatus.Error,\n        }\n      }\n\n      let pageData = result.payload\n      const { componentChunkName, staticQueryHashes = [] } = pageData\n\n      const finalResult = {}\n\n      const componentChunkPromise = this.loadComponent(componentChunkName).then(\n        component => {\n          finalResult.createdAt = new Date()\n          let pageResources\n          if (!component) {\n            finalResult.status = PageResourceStatus.Error\n          } else {\n            finalResult.status = PageResourceStatus.Success\n            if (result.notFound === true) {\n              finalResult.notFound = true\n            }\n            pageData = Object.assign(pageData, {\n              webpackCompilationHash: allData[0]\n                ? allData[0].webpackCompilationHash\n                : ``,\n            })\n            pageResources = toPageResources(pageData, component)\n          }\n          // undefined if final result is an error\n          return pageResources\n        }\n      )\n\n      const staticQueryBatchPromise = Promise.all(\n        staticQueryHashes.map(staticQueryHash => {\n          // Check for cache in case this static query result has already been loaded\n          if (this.staticQueryDb.has(staticQueryHash)) {\n            const jsonPayload = this.staticQueryDb.get(staticQueryHash)\n            return { staticQueryHash, jsonPayload }\n          }\n\n          return this.memoizedGet(\n            `${__PATH_PREFIX__}/static/d/${staticQueryHash}.json`\n          ).then(req => {\n            const jsonPayload = JSON.parse(req.responseText)\n            return { staticQueryHash, jsonPayload }\n          })\n        })\n      ).then(staticQueryResults => {\n        const staticQueryResultsMap = {}\n\n        staticQueryResults.forEach(({ staticQueryHash, jsonPayload }) => {\n          staticQueryResultsMap[staticQueryHash] = jsonPayload\n          this.staticQueryDb.set(staticQueryHash, jsonPayload)\n        })\n\n        return staticQueryResultsMap\n      })\n\n      return Promise.all([componentChunkPromise, staticQueryBatchPromise]).then(\n        ([pageResources, staticQueryResults]) => {\n          let payload\n          if (pageResources) {\n            payload = { ...pageResources, staticQueryResults }\n            finalResult.payload = payload\n            emitter.emit(`onPostLoadPageResources`, {\n              page: payload,\n              pageResources: payload,\n            })\n          }\n\n          this.pageDb.set(pagePath, finalResult)\n\n          return payload\n        }\n      )\n    })\n\n    inFlightPromise\n      .then(response => {\n        this.inFlightDb.delete(pagePath)\n      })\n      .catch(error => {\n        this.inFlightDb.delete(pagePath)\n        throw error\n      })\n\n    this.inFlightDb.set(pagePath, inFlightPromise)\n\n    return inFlightPromise\n  }\n\n  // returns undefined if loading page ran into errors\n  loadPageSync(rawPath) {\n    const pagePath = findPath(rawPath)\n    if (this.pageDb.has(pagePath)) {\n      const pageData = this.pageDb.get(pagePath).payload\n      return pageData\n    }\n    return undefined\n  }\n\n  shouldPrefetch(pagePath) {\n    // Skip prefetching if we know user is on slow or constrained connection\n    if (!doesConnectionSupportPrefetch()) {\n      return false\n    }\n\n    // Check if the page exists.\n    if (this.pageDb.has(pagePath)) {\n      return false\n    }\n\n    return true\n  }\n\n  prefetch(pagePath) {\n    if (!this.shouldPrefetch(pagePath)) {\n      return false\n    }\n\n    // Tell plugins with custom prefetching logic that they should start\n    // prefetching this path.\n    if (!this.prefetchTriggered.has(pagePath)) {\n      this.apiRunner(`onPrefetchPathname`, { pathname: pagePath })\n      this.prefetchTriggered.add(pagePath)\n    }\n\n    // If a plugin has disabled core prefetching, stop now.\n    if (this.prefetchDisabled) {\n      return false\n    }\n\n    const realPath = findPath(pagePath)\n    // Todo make doPrefetch logic cacheable\n    // eslint-disable-next-line consistent-return\n    this.doPrefetch(realPath).then(() => {\n      if (!this.prefetchCompleted.has(pagePath)) {\n        this.apiRunner(`onPostPrefetchPathname`, { pathname: pagePath })\n        this.prefetchCompleted.add(pagePath)\n      }\n    })\n\n    return true\n  }\n\n  doPrefetch(pagePath) {\n    throw new Error(`doPrefetch not implemented`)\n  }\n\n  hovering(rawPath) {\n    this.loadPage(rawPath)\n  }\n\n  getResourceURLsForPathname(rawPath) {\n    const pagePath = findPath(rawPath)\n    const page = this.pageDataDb.get(pagePath)\n    if (page) {\n      const pageResources = toPageResources(page.payload)\n\n      return [\n        ...createComponentUrls(pageResources.page.componentChunkName),\n        createPageDataUrl(pagePath),\n      ]\n    } else {\n      return null\n    }\n  }\n\n  isPageNotFound(rawPath) {\n    const pagePath = findPath(rawPath)\n    const page = this.pageDb.get(pagePath)\n    return page && page.notFound === true\n  }\n\n  loadAppData(retries = 0) {\n    return this.memoizedGet(`${__PATH_PREFIX__}/page-data/app-data.json`).then(\n      req => {\n        const { status, responseText } = req\n\n        let appData\n\n        if (status !== 200 && retries < 3) {\n          // Retry 3 times incase of non-200 responses\n          return this.loadAppData(retries + 1)\n        }\n\n        // Handle 200\n        if (status === 200) {\n          try {\n            const jsonPayload = JSON.parse(responseText)\n            if (jsonPayload.webpackCompilationHash === undefined) {\n              throw new Error(`not a valid app-data response`)\n            }\n\n            appData = jsonPayload\n          } catch (err) {\n            // continue regardless of error\n          }\n        }\n\n        return appData\n      }\n    )\n  }\n}\n\nconst createComponentUrls = componentChunkName =>\n  (window.___chunkMapping[componentChunkName] || []).map(\n    chunk => __PATH_PREFIX__ + chunk\n  )\n\nexport class ProdLoader extends BaseLoader {\n  constructor(asyncRequires, matchPaths) {\n    const loadComponent = chunkName =>\n      asyncRequires.components[chunkName]\n        ? asyncRequires.components[chunkName]()\n            .then(preferDefault)\n            // loader will handle the case when component is null\n            .catch(() => null)\n        : Promise.resolve()\n\n    super(loadComponent, matchPaths)\n  }\n\n  doPrefetch(pagePath) {\n    const pageDataUrl = createPageDataUrl(pagePath)\n    return prefetchHelper(pageDataUrl, {\n      crossOrigin: `anonymous`,\n      as: `fetch`,\n    })\n      .then(() =>\n        // This was just prefetched, so will return a response from\n        // the cache instead of making another request to the server\n        this.loadPageDataJson(pagePath)\n      )\n      .then(result => {\n        if (result.status !== PageResourceStatus.Success) {\n          return Promise.resolve()\n        }\n        const pageData = result.payload\n        const chunkName = pageData.componentChunkName\n        const componentUrls = createComponentUrls(chunkName)\n        return Promise.all(componentUrls.map(prefetchHelper)).then(\n          () => pageData\n        )\n      })\n  }\n\n  loadPageDataJson(rawPath) {\n    return super.loadPageDataJson(rawPath).then(data => {\n      if (data.notFound) {\n        // check if html file exist using HEAD request:\n        // if it does we should navigate to it instead of showing 404\n        return doFetch(rawPath, `HEAD`).then(req => {\n          if (req.status === 200) {\n            // page (.html file) actually exist (or we asked for 404 )\n            // returning page resources status as errored to trigger\n            // regular browser navigation to given page\n            return {\n              status: PageResourceStatus.Error,\n            }\n          }\n\n          // if HEAD request wasn't 200, return notFound result\n          // and show 404 page\n          return data\n        })\n      }\n      return data\n    })\n  }\n}\n\nlet instance\n\nexport const setLoader = _loader => {\n  instance = _loader\n}\n\nexport const publicLoader = {\n  // Deprecated methods. As far as we're aware, these are only used by\n  // core gatsby and the offline plugin, however there's a very small\n  // chance they're called by others.\n  getResourcesForPathname: rawPath => {\n    console.warn(\n      `Warning: getResourcesForPathname is deprecated. Use loadPage instead`\n    )\n    return instance.i.loadPage(rawPath)\n  },\n  getResourcesForPathnameSync: rawPath => {\n    console.warn(\n      `Warning: getResourcesForPathnameSync is deprecated. Use loadPageSync instead`\n    )\n    return instance.i.loadPageSync(rawPath)\n  },\n  enqueue: rawPath => instance.prefetch(rawPath),\n\n  // Real methods\n  getResourceURLsForPathname: rawPath =>\n    instance.getResourceURLsForPathname(rawPath),\n  loadPage: rawPath => instance.loadPage(rawPath),\n  loadPageSync: rawPath => instance.loadPageSync(rawPath),\n  prefetch: rawPath => instance.prefetch(rawPath),\n  isPageNotFound: rawPath => instance.isPageNotFound(rawPath),\n  hovering: rawPath => instance.hovering(rawPath),\n  loadAppData: () => instance.loadAppData(),\n}\n\nexport default publicLoader\n"]},"metadata":{},"sourceType":"module"}